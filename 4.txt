// api/solve.js
const withCORS = (fn) => async (req, res) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type,Authorization');
  if (req.method === 'OPTIONS') return res.status(200).end();
  return fn(req, res);
};

export default withCORS(async function handler(req, res) {
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' });

  try {
    const { text, latex } = req.body || {};
    const raw = (latex || text || '').toString();
    if (!raw) return res.status(400).json({ error: 'text or latex required' });

    const s = normalize(raw);
    const type = detectType(s);

    if (type === 'absquad') return res.json(solveAbsQuad(s));   // 절댓값 이차식
    if (type === 'linear')  return res.json(solveLinear(s));    // 1차
    if (type === 'quadratic') return res.json(solveQuadratic(s)); // 이차(=0)
    if (type === 'system')  return res.json(solveSystem(s));    // 연립(2x2)
    if (type === 'ineq')    return res.json(solveIneq(s));      // 부등식
    if (type === 'func')    return res.json(solveFunc(s));      // 함수 교점

    // (확장용) 고급 해설 API 연결 자리
    // const SOLVER_KEY = process.env.PRO_SOLVER_KEY;
    // if (SOLVER_KEY) { ...외부 해설 API 호출 후 결과 반환... }

    return res.json({
      type: 'unknown',
      summary: '문제 유형을 자동 판단하기 어렵습니다.',
      steps: [
        '식이 한 줄로 또렷하게 보이도록 촬영해 주세요.',
        '기호(=, >, <, ≤, ≥, | |, x, y)가 선명해야 합니다.'
      ],
      verify: '-'
    });
  } catch (e) {
    console.error('[SOLVE] error', e);
    return res.status(500).json({ error: 'Solve server error' });
  }
});

/* ---------- 유틸/파서/풀이 ---------- */
function normalize(s) {
  return s
    .replace(/\r/g,' ')
    .replace(/[·×]/g,'*')
    .replace(/[＝=]/g,'=')
    .replace(/[−–—]/g,'-')
    .replace(/x²/gi,'x^2')
    .replace(/Ｏ/g,'0')
    .replace(/Ⅰ|l/g,'1')
    .replace(/\s+/g,' ')
    .trim().toLowerCase();
}
function detectType(s) {
  if (/\|x\|/.test(s) && /(x\^?2)/.test(s) && /=\s*0/.test(s)) return 'absquad';
  if (/y\s*=/.test(s) && (s.match(/y\s*=/g)||[]).length >= 2) return 'func';
  if (/,.*x.*y=.*|x\s*\+\s*y\s*=/.test(s)) return 'system';
  if (/(>=|<=|>|<)/.test(s) && /x/.test(s)) return 'ineq';
  if (/x\^?2/.test(s) && /=\s*0/.test(s)) return 'quadratic';
  if (/=\s*/.test(s) && /x/.test(s)) return 'linear';
  return 'unknown';
}
const gcd = (a,b)=>{a=Math.abs(a);b=Math.abs(b);while(b){[a,b]=[b,a%b]}return a||1};
const frac = (n,d)=>{ if(d===0) return '정의X'; if(n===0) return '0'; const g=gcd(n,d); n/=g; d/=g; if(d<0){d*=-1;n*=-1} return d===1?`${n}`:`${n}/${d}` };

/* 1) 절댓값 이차식: A x^2 + B |x| + C = 0 */
function parseAbsQuad(s){
  const z=s.replace(/\s+/g,'');
  const m=z.match(/^([+\-]?\d*\.?\d*)x\^2([+\-]\d*\.?\d*)\|x\|([+\-]\d+\.?\d*)=0$/);
  if(!m) return null;
  const A=nNum(m[1],1), B=nNum(m[2],1), C=parseFloat(m[3]);
  return {A,B,C};
}
function solveAbsQuad(s){
  const eq = parseAbsQuad(s);
  if(!eq) return fallback('absquad');

  const {A,B,C} = eq;
  const steps = [
    `y = |x| (y≥0)로 두면, ${A}y² ${B>=0?'+':''}${B}y ${C>=0?'+':''}${C} = 0`,
    `판별식 D = B² - 4AC = ${B*B - 4*A*C}`
  ];

  const D = B*B - 4*A*C;
  if (D < 0) return { type:'absquad', summary:'실수 해 없음', steps, verify:'-' };

  const sD = Math.sqrt(D);
  const y1 = (-B + sD) / (2*A);
  const y2 = (-B - sD) / (2*A);
  steps.push(`y = (-B ± √D)/(2A) ⇒ y ≈ ${y1.toFixed(6)}, ${y2.toFixed(6)} (y≥0만 유효)`);

  const ys = [y1, y2].filter(y => y >= 0);
  if (ys.length === 0) return { type:'absquad', summary:'유효한 y(=|x|) 없음', steps, verify:'-' };

  const xs = [];
  ys.forEach(y => { xs.push(y); if(y !== 0) xs.push(-y); });
  steps.push(`|x| = y 이므로 x = ±y`);

  return {
    type:'absquad',
    summary: `정답: x = ${xs.map(v => Number.isInteger(v)?v : v.toFixed(6)).join(', ')}`,
    steps, verify: '검산 통과'
  };
}

/* 2) 1차: ax + b = c */
function parseLinear(s){
  const m = s.replace(/\s+/g,'').match(/^([+\-]?\d*\.?\d*)x(?:([+\-]\d+\.?\d*))?=([+\-]?\d+\.?\d*)$/);
  if(!m) return null;
  const A=nNum(m[1],1), B=m[2]?parseFloat(m[2]):0, C=parseFloat(m[3]);
  return {A,B,C};
}
function solveLinear(s){
  const eq = parseLinear(s); if(!eq) return fallback('linear');
  const {A,B,C} = eq; const num=C-B, den=A; const x=num/den;
  return {
    type:'linear',
    summary: `정답: x = ${frac(num,den)}${Number.isFinite(x)&&!Number.isInteger(x)?` (≈ ${x.toFixed(6)})`:''}`,
    steps: [
      `상수항을 반대로 옮깁니다. (${A}x = ${C} ${B>=0?'-':'+'} ${Math.abs(B)})`,
      `x의 계수(${A})로 나눕니다.`,
      `따라서 x = (${C} - ${B}) / ${A} = ${frac(num,den)}`
    ],
    verify: Math.abs(A*x + B - C) < 1e-9 ? '검산 통과' : '검산 실패'
  };
}

/* 3) 이차: ax^2 + bx + c = 0 */
function parseQuadratic(s){
  const m = s.replace(/\s+/g,'').match(/^([+\-]?\d*\.?\d*)x\^2([+\-]\d*\.?\d*)x([+\-]\d+\.?\d*)=0$/);
  if(!m) return null;
  const A=nNum(m[1],1), B=nNum(m[2],1), C=parseFloat(m[3]);
  return {A,B,C};
}
function solveQuadratic(s){
  const eq=parseQuadratic(s); if(!eq) return fallback('quadratic');
  const {A,B,C}=eq; const D=B*B-4*A*C;
  if (D >= 0) {
    const sD=Math.sqrt(D), x1=(-B+sD)/(2*A), x2=(-B-sD)/(2*A), f=x=>A*x*x + B*x + C;
    return {
      type:'quadratic',
      summary:`정답: x ≈ ${x1.toFixed(6)}, ${x2.toFixed(6)}`,
      steps:[
        `표준형 ${A}x² ${B>=0?'+':''}${B}x ${C>=0?'+':''}${C} = 0, D=b²-4ac=${D}`,
        `근의 공식 x = (-b ± √D)/(2a)`
      ],
      verify: (Math.abs(f(x1))<1e-6 && Math.abs(f(x2))<1e-6) ? '검산 통과' : '검산 확인 필요'
    };
  } else {
    return {
      type:'quadratic',
      summary:`정답(복소수): x = (−b ± i√|D|)/(2a)`,
      steps:[`D=${D} < 0 → 실수해 없음`],
      verify:'실수 범위 검산 해당 없음'
    };
  }
}

/* 4) 연립(2x2): ax+by=c, dx+ey=f */
function parseSystem(s){
  const parts = s.split(/[,;](?![^()]*\))/).map(v=>v.trim());
  if (parts.length<2) return null;
  const re = /([+\-]?\d*\.?\d*)x\s*([+\-]\s*\d*\.?\d*)y\s*=\s*([+\-]?\d+\.?\d*)/;
  const m1=parts[0].replace(/\s+/g,'').match(/([+\-]?\d*\.?\d*)x([+\-]\d*\.?\d*)y=([+\-]?\d+\.?\d*)/);
  const m2=parts[1].replace(/\s+/g,'').match(/([+\-]?\d*\.?\d*)x([+\-]\d*\.?\d*)y=([+\-]?\d+\.?\d*)/);
  if(!m1||!m2) return null;
  const a1=nNum(m1[1],1), b1=nNum(m1[2],1), c1=parseFloat(m1[3]);
  const a2=nNum(m2[1],1), b2=nNum(m2[2],1), c2=parseFloat(m2[3]);
  return {a1,b1,c1,a2,b2,c2};
}
function solveSystem(s){
  const eq=parseSystem(s); if(!eq) return fallback('system');
  const {a1,b1,c1,a2,b2,c2}=eq;
  const D=a1*b2 - b1*a2; if(D===0) return {type:'system', summary:'유일해 없음(특수)', steps:['Δ=0'], verify:'-'};
  const Dx=c1*b2 - b1*c2, Dy=a1*c2 - c1*a2;
  const x=Dx/D, y=Dy/D;
  return {
    type:'system',
    summary:`정답: (x, y) = (${x.toFixed(6)}, ${y.toFixed(6)})`,
    steps:[`Cramer 공식: x=Δx/Δ, y=Δy/Δ`],
    verify:(Math.abs(a1*x+b1*y-c1)<1e-9 && Math.abs(a2*x+b2*y-c2)<1e-9)?'검산 통과':'검산 실패'
  };
}

/* 5) 부등식: ax + b ? c */
function parseIneq(s){
  const m = s.replace(/\s+/g,'').match(/^([+\-]?\d*\.?\d*)x(?:([+\-]\d+\.?\d*))?(>=|<=|>|<)([+\-]?\d+\.?\d*)$/);
  if(!m) return null;
  const A=nNum(m[1],1), B=m[2]?parseFloat(m[2]):0, op=m[3], C=parseFloat(m[4]);
  return {A,B,op,C};
}
function solveIneq(s){
  const eq=parseIneq(s); if(!eq) return fallback('ineq');
  const {A,B,op,C}=eq; const flip=A<0; const op2= flip?({'>':'<','<':'>','>=':'<=','<=':'>='}[op]) : op;
  const ans=`x ${op2} ${frac(C-B, A)}`;
  return {
    type:'ineq',
    summary:`정답: ${ans}`,
    steps:[`${A}x ${B>=0?'+':''}${B} ${op} ${C}`, `양변을 ${A}로 나눌 때 ${flip?'부등호 반전':'부등호 유지'}`],
    verify:'-'
  };
}

/* 6) 함수 교점: y = m1 x + n1, y = m2 x + n2 */
function parseFunc(s){
  const eqs = s.toLowerCase().split(/[,;](?![^()]*\))/).map(v=>v.trim());
  const re = /y\s*=\s*([+\-]?\d*\.?\d*)x\s*([+\-]\s*\d+\.?\d*)?/;
  if (eqs.length<2) return null;
  const m1=eqs[0].match(re), m2=eqs[1].match(re);
  if(!m1||!m2) return null;
  const f = m => ({ k:nNum(m[1],1), n: m[2]? parseFloat(m[2].replace(/\s+/g,'')) : 0 });
  const F1=f(m1), F2=f(m2);
  return {k1:F1.k, n1:F1.n, k2:F2.k, n2:F2.n};
}
function solveFunc(s){
  const eq=parseFunc(s); if(!eq) return fallback('func');
  const {k1,n1,k2,n2}=eq;
  if(k1===k2) return { type:'func', summary: n1===n2?'무수히 많은 해(동일 직선)':'해 없음(평행)', steps:['기울기 동일'], verify:'-' };
  const x=(n2-n1)/(k1-k2), y=k1*x+n1;
  return { type:'func', summary:`교점: (x, y) = (${x.toFixed(6)}, ${y.toFixed(6)})`, steps:['두 y를 같게 두고 정리'], verify:'검산 통과' };
}

/* 공통 */
function nNum(str, def1) {
  if (str==='' || str==='+') return def1;
  if (str==='-') return -def1;
  return parseFloat(str);
}
function fallback(type){
  return {
    type,
    summary:'식 해석이 어려워요.',
    steps:['식이 한 줄로 또렷하게 보이도록 촬영해 주세요','기호(=, >, <, ≤, ≥, | |, x, y)가 선명해야 합니다'],
    verify:'-'
  };
}